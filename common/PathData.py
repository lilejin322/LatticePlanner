from enum import Enum
from typing import List, Tuple
from common.ReferenceLine import ReferenceLine
from protoclass.PathPoint import PathPoint
from protoclass.FrenetFramePoint import FrenetFramePoint
from common.DiscretizedPath import DiscretizedPath
from common.FrenetFramePath import FrenetFramePath

class PathPointType(Enum):

    IN_LANE = 0
    OUT_ON_FORWARD_LANE = 1
    OUT_ON_REVERSE_LANE = 2
    OFF_ROAD = 3
    UNKNOWN = 4

class PathData:
    """
    PathData class
    """

    def __init__(self):
        """
        Constructor
        """

        self._reference_line: ReferenceLine = None
        self._discretized_path: DiscretizedPath = DiscretizedPath()
        self._frenet_path: FrenetFramePath = FrenetFramePath()

        self._path_point_decision_guide: List[Tuple[float, PathPointType, float]] = []
        """
        speed decision generated by path analyzer for guiding speed limit
        generation in speed bounds decider
        tuple consists of s axis position on reference line; PathPointType
        Enum; distance to closest obstacle
        """
        self._path_label: str = ""
        self._blocking_obstacle_id: str = ""

        self._is_valid_path_reference: bool = False
        """
        parameters for using the learning model output as a path reference
        wheter this PathData is a path reference serving as an optimization target
        for later modules
        """
        self._is_optimized_towards_trajectory_reference = False
        """
        Given a trajectory reference, whether this PathData is optimized
        according to the "path" part of the trajectory so that "speed" part of the
        trajectory could be used in later modules accordingly
        """
        self._is_reverse_path = False
        self._path_reference: List[PathPoint] = []
        """path reference"""

    def SetDiscretizedPath(self, path: DiscretizedPath) -> bool:
        """
        Set the discretized path

        :param DiscretizedPath path: The discretized path
        :returns: True if successful, False otherwise
        :rtype: bool
        """

        raise NotImplementedError

    def SetFrenetPath(self, frenet_path: FrenetFramePath) -> bool:
        """
        Set the frenet path

        :param FrenetFramePath frenet_path: The frenet path
        :returns: True if successful, False otherwise
        :rtype: bool
        """
        
        raise NotImplementedError

    def SetReferenceLine(self, reference_line: ReferenceLine) -> None:
        """
        Set the reference line

        :param ReferenceLine reference_line: The reference line
        """

        raise NotImplementedError

    def SetPathPointDecisionGuide(self, path_point_decision_guide: List[Tuple[float, PathPointType, float]]) -> bool:
        """
        Set the path point decision guide

        :param List[Tuple[float, PathPointType, float]] path_point_decision_guide: The path point decision guide
        :returns: True if successful, False otherwise
        :rtype: bool
        """
    
        raise NotImplementedError

    def discretized_path(self) -> DiscretizedPath:
        """
        Get the discretized path

        :returns: The discretized path
        :rtype: DiscretizedPath
        """

        raise NotImplementedError

    def frenet_frame_path(self) -> FrenetFramePath:
        """
        Get the frenet path

        :returns: The frenet path
        :rtype: FrenetFramePath
        """

        raise NotImplementedError

    def path_point_decision_guide(self) -> List[Tuple[float, PathPointType, float]]:
        """
        Get the path point decision guide

        :returns: The path point decision guide
        :rtype: List[Tuple[float, PathPointType, float]]
        """

        raise NotImplementedError

    def GetPathPointWithPathS(self, s: float) -> PathPoint:
        """
        Get the path point with the given s value

        :param float s: The s value
        """

        raise NotImplementedError

    def GetPathPointWithRefS(self, ref_s: float) -> PathPoint:
        """
        this function will find the path_point in discretized_path whose
        projection to reference line has s value closest to ref_s.

        :param float ref_s: The reference s value
        :returns: The path point
        :rtype: PathPoint
        """

        raise NotImplementedError

    def LeftTrimWithRefS(self, frenet_point: FrenetFramePoint) -> bool:
        """
        Left trim with ref_s

        :param FrenetFramePoint frenet_point: The frenet point
        :returns: True if successful, False otherwise
        :rtype: bool
        """

        raise NotImplementedError

    def UpdateFrenetFramePath(self, reference_line: ReferenceLine) -> bool:
        """
        Update the frenet frame path

        :param ReferenceLine reference_line: The reference line
        :returns: True if successful, False otherwise
        :rtype: bool
        """

        raise NotImplementedError

    def Clear(self) -> None:
        """
        Clear method
        """

        raise NotImplementedError

    def Empty(self) -> bool:
        """
        Judge if the path is empty
        """

        raise NotImplementedError

    def __str__(self) -> str:
        """
        String representation of the PathData object

        :returns: The string representation of the PathData object
        :rtype: str
        """

        raise NotImplementedError

    def set_path_label(self, label: str) -> None:
        """
        Set the path label

        :param str label: The path label
        """

        raise NotImplementedError

    def path_label(self) -> str:
        """
        Get the path label

        :returns: The path label
        :rtype: str
        """

        raise NotImplementedError

    def set_blocking_obstacle_id(self, obs_id: str) -> None:
        """
        Set the blocking obstacle id

        :param str obs_id: The blocking obstacle id
        """

        self._blocking_obstacle_id = obs_id

    def blocking_obstacle_id(self) -> str:
        """
        Get the blocking obstacle id

        :returns: The blocking obstacle id
        :rtype: str
        """

        return self._blocking_obstacle_id

    def is_valid_path_reference(self) -> bool:
        """
        Check if the path reference is valid

        :returns: True if the path reference is valid, False otherwise
        :rtype: bool
        """

        return self._is_valid_path_reference

    def set_is_valid_path_reference(self, is_valid_path_reference: bool) -> None:
        """
        Set the is valid path reference flag

        :param bool is_valid_path_reference: The is valid path reference flag to set
        """

        self._is_valid_path_reference = is_valid_path_reference

    def is_optimized_towards_trajectory_reference(self) -> bool:
        """
        Check if the path is optimized towards the trajectory reference

        :returns: True if the path is optimized towards the trajectory reference, False otherwise
        :rtype: bool
        """

        return self._is_optimized_towards_trajectory_reference

    def set_is_optimized_towards_trajectory_reference(self, is_optimized_towards_trajectory_reference: bool) -> None:
        """
        Set the is optimized towards trajectory reference flag

        :param bool is_optimized_towards_trajectory_reference: The is optimized towards trajectory reference flag to set
        """

        self._is_optimized_towards_trajectory_reference = is_optimized_towards_trajectory_reference

    def path_reference(self) -> List[PathPoint]:
        """
        Get the path reference

        :returns: The path reference
        :rtype: List[PathPoint]
        """

        raise NotImplementedError

    def set_path_reference(self, path_reference: List[PathPoint]) -> None:
        """
        Set the path reference

        :param List[PathPoint] path_reference: The path reference
        """

        raise NotImplementedError

    def is_reverse_path(self) -> bool:
        """
        Check if the path is a reverse path

        :returns: True if the path is a reverse path, False otherwise
        :rtype: bool
        """

        return self._is_reverse_path

    def set_is_reverse_path(self, is_reverse_path: bool) -> None:
        """
        Set the is reverse path flag

        :param bool is_reverse_path: The is reverse path flag to set
        """

        self._is_reverse_path = is_reverse_path

    def SLToXY(self, frenet_path: FrenetFramePath) -> Tuple[bool, DiscretizedPath]:
        """
        convert frenet path to cartesian path by reference line

        :param FrenetFramePath frenet_path: The frenet path
        :returns: A tuple of success flag and the discretized path
        :rtype: Tuple[bool, DiscretizedPath]
        """

        raise NotImplementedError

    def XYToSL(self, discretized_path: DiscretizedPath) -> Tuple[bool, FrenetFramePath]:
        """
        convert cartesian path to frenet path by reference line

        :param DiscretizedPath discretized_path: The discretized path
        :returns: A tuple of success flag and the frenet path
        :rtype: Tuple[bool, FrenetFramePath]
        """

        raise NotImplementedError
