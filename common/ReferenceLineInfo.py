from typing import List, Dict, Tuple
from enum import Enum
from protoclass.TrajectoryPoint import TrajectoryPoint
from common.ReferenceLine import ReferenceLine
from common.RouteSegments import RouteSegments
from common.Obstacle import Obstacle
from common.DiscretizedTrajectory import DiscretizedTrajectory
from protoclass.SLBoundary import SLBoundary
from protoclass.ADCTrajectory import ADCTrajectory
from protoclass.Lane import Lane
from common.Path import PathOverlap
from protoclass.SLBoundary import SLPoint
from protoclass.DecisionResult import DecisionResult, VehicleSignal, ObjectDecisions
from protoclass.VehicleState import VehicleState
from common.PathData import PathData
from common.PathDecision import PathDecision
from common.SpeedData import SpeedData
from protoclass.LatencyStats import LatencyStats
from protoclass.EngageAdvice import EngageAdvice
from common.PathBoundary import PathBoundary
from common.PlanningContext import PlanningContext
from protoclass.RSSInfo import RSSInfo
from protoclass.lattice_structure import StopPoint, PlanningTarget
from common.StGraphData import StGraphData
from common.LaneInfo import LaneInfo
from config import FRONT_EDGE_TO_CENTER, BACK_EDGE_TO_CENTER, LEFT_EDGE_TO_CENTER, RIGHT_EDGE_TO_CENTER, \
                   EGO_VEHICLE_LENGTH, EGO_VEHICLE_WIDTH, FLAGS_speed_bump_speed_limit, FLAGS_default_cruise_speed
from common.Vec2d import Vec2d
from common.Box2d import Box2d
from logging import Logger
from common.ReferencePoint import ReferencePoint
import copy

logger = Logger("ReferenceLineInfo")

def WithinOverlap(overlap: PathOverlap, s: float) -> bool:
    """
    Check if the s is within the overlap

    :param PathOverlap overlap: The overlap
    :param float s: The s value
    :returns: True if the s is within the overlap, otherwise False.
    :rtype: bool
    """

    kEpsilon: float = 1e-2
    return overlap.start_s - kEpsilon <= s <= overlap.end_s + kEpsilon

class ReferenceLineInfo:
    """
    ReferenceLineInfo holds all data for one reference line.
    """

    class LaneType(Enum):

        LeftForward = 0
        LeftReverse = 1
        RightForward = 2
        RightReverse = 3

    class OverlapType(Enum):
        """
        different types of overlaps that can be handled by different scenarios.
        """

        CLEAR_AREA = 1
        CROSSWALK = 2
        OBSTACLE = 3
        PNC_JUNCTION = 4
        SIGNAL = 5
        STOP_SIGN = 6
        YIELD_SIGN = 7
        JUNCTION = 8

    def __init__(self, vehicle_state: VehicleState=None, adc_planning_point: TrajectoryPoint=None, reference_line: ReferenceLine=None, segments: RouteSegments=None):
        """
        Constructor
        """

        self._vehicle_state = vehicle_state
        self._adc_planning_point = adc_planning_point
        self._reference_line = reference_line
        self._lanes: RouteSegments = segments
        # this is the number that measures the goodness of this reference line.
        # The lower the better.
        self._cost: float = 0.0
        self._is_drivable: bool = True
        self._path_decision: PathDecision = None
        self._blocking_obstacle: Obstacle = None
        self._candidate_path_boundaries: List[PathBoundary] = []
        self._candidate_path_data: List[PathData] = []
        self._path_data: PathData = None
        self._fallback_path_data: PathData = None
        self._speed_data: SpeedData = None
        self._discretized_trajectory: DiscretizedTrajectory = None
        self._rss_info: RSSInfo = None
        # SL boundary of stitching point (starting point of plan trajectory)
        # relative to the reference line
        self._adc_sl_boundary: SLBoundary = None
        self._latency_stats: LatencyStats = None
        self._is_on_reference_line: bool = False
        self._is_path_lane_borrow: bool = False
        self._status: ADCTrajectory.RightOfWayStatus = ADCTrajectory.RightOfWayStatus.UNPROTECTED
        self._offset_to_other_reference_line: float = 0.0
        self._priority_cost: float = 0.0
        self._planning_target: PlanningTarget = None
        self._trajectory_type = ADCTrajectory.TrajectoryType.UNKNOWN
        # Overlaps encountered in the first time along the reference line in front of
        # the vehicle
        self._first_encounter_overlaps: List[Tuple[ReferenceLineInfo.OverlapType, PathOverlap]] = []
        # Data generated by speed_bounds_decider for constructing st_graph for
        # different st optimizer
        self._st_graph_data: StGraphData = None
        self._vehicle_signal: VehicleSignal = None
        self._cruise_speed = 0.0
        self._base_cruise_speed = 0.0
        self._path_reusable = False
        self._junction_right_of_way_map: Dict[str, bool] = {}

    def Init(self, obstacles: List[Obstacle], target_speed: float) -> bool:
        """

        returns: True if successful, False otherwise
        rtype: bool
        """

        # stiching point
        path_point = self._adc_planning_point.path_point
        position: Vec2d = Vec2d(path_point.x, path_point.y)
        vec_to_center: Vec2d = Vec2d((FRONT_EDGE_TO_CENTER - BACK_EDGE_TO_CENTER) / 2.0, (LEFT_EDGE_TO_CENTER - RIGHT_EDGE_TO_CENTER) / 2.0)
        center: Vec2d = position + vec_to_center.rotate(path_point.theta)
        box: Box2d = Box2d(center, path_point.theta, EGO_VEHICLE_LENGTH, EGO_VEHICLE_WIDTH)
        # realtime vehicle position
        vehicle_position: Vec2d = Vec2d(self._vehicle_state.x, self._vehicle_state.y)
        vehicle_center: Vec2d = Vec2d(vehicle_position + vec_to_center.rotate(self._vehicle_state.heading))
        vehicle_box: Box2d = Box2d(vehicle_center, self._vehicle_state.heading, EGO_VEHICLE_LENGTH, EGO_VEHICLE_WIDTH)
        if not self._reference_line.GetSLBoundary(box, self._adc_sl_boundary):
            logger.error(f"Failed to get ADC boundary from box: {box}")
            return False
        
        self.InitFirstOverlaps()

        if self._adc_sl_boundary.end_s < 0 or self._adc_sl_boundary.start_s > self._reference_line.Length():
            logger.warning(f"Vehicle SL {self._adc_sl_boundary} is not on reference line: [0, {self._reference_line.Length()}]")
        
        kOutOfReferenceLineL = 14.0;       # in meters
        if self._adc_sl_boundary.start_l > kOutOfReferenceLineL or self._adc_sl_boundary.end_l < -kOutOfReferenceLineL:
            logger.error(f"Ego vehicle is too far away from reference line. self._adc_sl_boundary.start_l: {self._adc_sl_boundary.start_l}, self._adc_sl_boundary.end_l: {self._adc_sl_boundary.end_l}")
            return False
        self._is_on_reference_line = self._reference_line.IsOnLane(self._adc_sl_boundary)
        if not self.AddObstacles(obstacles):
            logger.error(f"Failed to add obstacles to reference line")
            return False
        
        map_path = self._reference_line.map_path
        for speed_bump in map_path.speed_bump_overlaps:
            # -1 and + 1.0 are added to make sure it can be sampled.
            self._reference_line.AddSpeedLimit(speed_bump.start_s - 1.0, speed_bump.end_s + 1.0, FLAGS_speed_bump_speed_limit)

        self.SetCruiseSpeed(target_speed)
        # set lattice planning target speed limit;
        self.SetLatticeCruiseSpeed(target_speed)

        self._vehicle_signal = None

        return True

    def AddObstacles(self, obstacles: List[Obstacle]) -> bool:
        """
        Add obstacles to the reference line info

        param List[Obstacle] obstacles: List of obstacles to add
        returns: True if successful, False otherwise
        rtype: bool
        """

        raise NotImplementedError
    
    def AddObstacle(self, obstacle: Obstacle) -> Obstacle:
        """
        Add an obstacle to the reference line info
        
        (Note this part in cpp is weird using pointer, should take a deeper look)
        param Obstacle obstacle: Obstacle to add
        returns: The added obstacle
        rtype: Obstacle
        """

        raise NotImplementedError


    @property
    def vehicle_state(self) -> VehicleState:
        """
        Get the vehicle state

        returns: The vehicle state
        rtype: VehicleState
        """

        return self._vehicle_state
    
    @property
    def path_decision(self) -> PathDecision:
        """
        Get the path decision

        returns: The path decision
        rtype: PathDecision
        """

        return self._path_decision
    
    @property
    def reference_line(self) -> ReferenceLine:
        """
        Get the reference line

        returns: The reference line
        rtype: ReferenceLine
        """

        return self._reference_line
    
    def SDistanceToDestination(self) -> float:
        """
        """

        raise NotImplementedError
    
    def ReachedDestination(self) -> bool:
        """
        """

        raise NotImplementedError
    
    def SetTrajectory(self, trajectory: DiscretizedTrajectory) -> None:
        """
        Set the trajectory

        :param DiscretizedTrajectory trajectory: The trajectory to set
        """

        self._discretized_trajectory = trajectory
    
    def trajectory(self) -> DiscretizedTrajectory:
        """
        """

        raise NotImplementedError
    
    @property
    def Cost(self) -> float:
        """
        """

        return self._cost
    
    def AddCost(self, cost: float) -> None:
        """
        Add cost to the current cost

        :param float cost: The cost to add
        """

        self._cost += cost
    
    def SetCost(self, cost: float) -> None:
        """
        Set the cost

        :param float cost: The cost to set
        """

        self._cost = cost
    
    @property
    def PriorityCost(self) -> float:
        """
        Get the priority cost

        returns: The priority cost
        rtype: float
        """

        return self._priority_cost
    
    def SetPriorityCost(self, cost: float) -> None:
        """

        :param float cost: The cost to set
        """

        self._priority_cost = cost
    
    def SetLatticeStopPoint(stop_point: StopPoint) -> None:
        """
        Set the lattice stop point
        For lattice planner'speed planning target

        :param StopPoint stop_point: The stop point to set
        """

        raise NotImplementedError
    
    def SetLatticeCruiseSpeed(speed: float) -> None:
        """
        Set the lattice cruise speed
        For lattice planner'speed planning target

        :param float speed: The speed to set
        """

        raise NotImplementedError

    @property
    def planning_target(self) -> PlanningTarget:
        """
        Get the planning target
        For lattice planner'speed planning target
        """

        return self._planning_target
    
    def SetCruiseSpeed(self, speed: float) -> None:
        """
        Set the cruise speed

        :param float speed: The speed to set
        """

        self._cruise_speed = speed
        self._base_cruise_speed = speed
    
    def LimitCruiseSpeed(self, speed: float) -> None:
        """
        Limit the cruise speed based on the "base_cruise_speed_". If the new
        setting speed > "base_cruise_speed_", it will be ignored.
        
        :param float speed: The new speed.
        """

        if self._base_cruise_speed <= speed:
            return
        self._cruise_speed = speed
    
    def GetBaseCruiseSpeed(self) -> float:
        """
        Get the base cruise speed
        """

        return self._base_cruise_speed if self._base_cruise_speed > 0.0 else FLAGS_default_cruise_speed
    
    def GetCruiseSpeed(self) -> float:
        """
        Get the cruise speed
        """

        return self._cruise_speed if self._cruise_speed > 0.0 else FLAGS_default_cruise_speed
    
    def LocateLaneInfo(self, s: float) -> LaneInfo:
        """
        Locate the lane info based on the s

        :param float s: The s value
        :returns: The lane info
        :rtype: LaneInfo
        """

        lanes: List[LaneInfo] = self._reference_line.GetLaneFromS(s)
        if not lanes:
            logger.warning(f"cannot get any lane using s: {s}.")
            return None
        
        return lanes[0]

    def GetNeighborLaneInfo(self, lane_type: LaneType, s: float) -> Tuple[bool, str, float]:
        """
        Get the neighbor lane info

        :param LaneType lane_type: The lane type
        :param float s: The s value
        :returns: The neighbor lane info, (bool, str lane_id, float lane_width)
        :rtype: Tuple[bool, str, float]
        """

        lane_info = self.LocateLaneInfo(s)
        if lane_info is None:
            return False, "", float("inf")
        
        if lane_type == self.LaneType.LeftForward:
            if not lane_info.lane.left_neighbor_forward_lane_id:
                return False, "", float("inf")
            lane_id = lane_info.lane.left_neighbor_forward_lane_id[0]
        
        elif lane_type == self.LaneType.LeftReverse:
            if not lane_info.lane.left_neighbor_reverse_lane_id:
                return False, "", float("inf")
            lane_id = lane_info.lane.left_neighbor_reverse_lane_id[0]

        elif lane_type == self.LaneType.RightForward:
            if not lane_info.lane.right_neighbor_forward_lane_id:
                return False, "", float("inf")
            lane_id = lane_info.lane.right_neighbor_forward_lane_id[0]
        
        elif lane_type == self.LaneType.RightReverse:
            if not lane_info.lane.right_neighbor_reverse_lane_id:
                return False, "", float("inf")
            lane_id = lane_info.lane.right_neighbor_reverse_lane_id[0]

        else:
            raise ValueError("Invalid LaneType")

        neighbor_lane = hdmap.HDMapUtil.BaseMapPtr().GetLaneById(lane_id)
        if neighbor_lane is None:
            return False, "", float("inf")
        
        ref_point: ReferencePoint = self._reference_line.GetReferencePoint(s)

        tag, neighbor_s, neighbor_l = neighbor_lane.GetProjection(Vec2d(ref_point.x, ref_point.y))
        if not tag:
            return False, "", float("inf")
        
        lane_width = neighbor_lane.GetWidth(neighbor_s)
        return True, lane_id, lane_width

    def IsStartFrom(previous_reference_line_info: 'ReferenceLineInfo') -> bool:
        """
        check if current reference line is started from another reference
        line info line. The method is to check if the start point of current
        reference line is on previous reference line info.

        :returns: True if current reference line starts on previous reference
        line, otherwise False.
        """

        raise NotImplementedError
    
    @property
    def latency_stats(self) -> LatencyStats:
        """
        Get the latency stats

        :returns: The latency stats
        :rtype: LatencyStats
        """

        return self._latency_stats
    
    def path_data(self) -> PathData:
        """
        Get the path data

        :returns: The path data
        :rtype: PathData
        """

        raise NotImplementedError
    
    def fallback_path_data(self) -> PathData:
        """
        Get the fallback path data

        :returns: The fallback path data
        :rtype: PathData
        """

        raise NotImplementedError
    
    def speed_data(self) -> SpeedData:
        """
        Get the speed data

        :returns: The speed data
        :rtype: SpeedData
        """

        raise NotImplementedError
    
    def rss_info(self) -> RSSInfo:
        """
        Get the rss info

        :returns: The rss info
        :rtype: RSSInfo
        """

        raise NotImplementedError
    
    def CombinePathAndSpeedProfile(relative_time: float, start_s: float, discretized_trajectory: DiscretizedTrajectory) -> bool:
        """
        aggregate final result together by some configuration
        """

        raise NotImplementedError
    
    def AdjustTrajectoryWhichStartsFromCurrentPos(planning_start_point: TrajectoryPoint,
                                                  trajectory: List[TrajectoryPoint]) -> DiscretizedTrajectory:
        """
        adjust trajectory if it starts from cur_vehicle postion rather planning
        init point from upstream

        :param TrajectoryPoint planning_start_point: The planning start point
        :param List[TrajectoryPoint] trajectory: The trajectory to adjust
        :returns: The adjusted trajectory
        :rtype: DiscretizedTrajectory
        """

        raise NotImplementedError
    
    def AdcSlBoundary(self) -> SLBoundary:
        """

        """

        return self._adc_sl_boundary
    
    def PathSpeedDebugString(self) -> str:
        """

        """

        raise NotImplementedError
    
    def IsChangeLanePath(self) -> bool:
        """
        Check if the current reference line is a change lane reference line, i.e.,
        ADC's current position is not on this reference line.

        :returns: True if it is a change lane reference line, otherwise False.
        :rtype: bool
        """

        raise NotImplementedError
    
    def IsNeighborLanePath(self) -> bool:
        """
        Check if the current reference line is the neighbor of the vehicle
        current position

        :returns: True if it is a neighbor lane reference line, otherwise False.
        :rtype: bool
        """

        raise NotImplementedError
    
    def SetDrivable(self, drivable: bool) -> None:
        """
        Set if the vehicle can drive following this reference line
        A planner need to set this value to true if the reference line is OK

        :param bool drivable: The value to set
        """

        raise NotImplementedError
    
    def IsDrivable(self) -> bool:
        """
        
        :returns: True if the vehicle can drive following this reference line, otherwise False.
        :rtype: bool
        """

        raise NotImplementedError
    
    def ExportEngageAdvice(self) -> Tuple[EngageAdvice, PlanningContext]:
        """

        """

        raise NotImplementedError
    
    @property
    def Lanes(self) -> RouteSegments:
        """
        Get the lanes

        :returns: The lanes
        :rtype: RouteSegments
        """

        return self._lanes
    
    def TargetLaneId(self) -> List[str]:
        """
        Get the target lane id

        :returns: The target lane id
        :rtype: List[str]
        """

        lane_ids: List[str] = []
        for lane_seg in self._lanes:
            lane_ids.append(lane_seg.lane.id)
        return lane_ids

    def ExportDecision(self) -> Tuple[DecisionResult, PlanningContext]:
        """


        :returns: (DecisionResult decision_result, PlanningContext planning_context)
        :rtype: Tuple[DecisionResult, PlanningContext]
        """

        raise NotImplementedError
    
    def SetJunctionRightOfWay(self, junction_s: float, is_protected: bool) -> None:
        """
        Set the junction right of way

        :param float junction_s: The s value of the junction
        :param bool is_protected: True if the junction is protected, otherwise False.
        """
        
        for overlap in self._reference_line.map_path.junction_overlaps:
            if WithinOverlap(overlap, junction_s):
                self._junction_right_of_way_map[overlap.object_id] = is_protected

    def GetRightOfWayStatus(self) -> ADCTrajectory.RightOfWayStatus:
        """
        Get the right of way status

        :returns: The right of way status
        :rtype: ADCTrajectory.RightOfWayStatus
        """

        for overlap in self._reference_line.map_path.junction_overlaps:
            if overlap.end_s < self._adc_sl_boundary.start_s:
                self._junction_right_of_way_map.pop(overlap.object_id)
            elif WithinOverlap(overlap, self._adc_sl_boundary.end_s):
                is_protected: bool = self._junction_right_of_way_map.get(overlap.object_id)
                if is_protected:
                    return ADCTrajectory.RightOfWayStatus.PROTECTED
    
        return ADCTrajectory.RightOfWayStatus.UNPROTECTED

    def GetPathTurnType(self, s: float) -> Lane.LaneTurn:
        """

        """

        raise NotImplementedError
    
    def GetIntersectionRightofWayStatus(self, pnc_junction_overlap: PathOverlap) -> bool:
        """

        """

        raise NotImplementedError

    @property
    def OffsetToOtherReferenceLine(self) -> float:
        """
        Get the offset to other reference line

        :returns: The offset to other reference line
        :rtype: float
        """

        return self._offset_to_other_reference_line
    
    def SetOffsetToOtherReferenceLine(self, offset: float) -> None:
        """
        Set the offset to other reference line

        :param float offset: The offset to set
        """

        self._offset_to_other_reference_line = offset
    
    def GetCandidatePathBoundaries(self) -> List[PathBoundary]:
        """
        Get the candidate path boundaries

        :returns: The candidate path boundaries
        :rtype: List[PathBoundary]
        """

        return self._candidate_path_boundaries
    
    def SetCandidatePathBoundaries(self, candidate_path_boundaries: List[PathBoundary]) -> None:
        """
        Set the candidate path boundaries

        :param PathBoundary candidate_path_boundaries: The candidate path boundaries to set
        """

        self._candidate_path_boundaries = candidate_path_boundaries

    def GetCandidatePathData(self) -> List[PathData]:
        """
        Get the candidate path data

        :returns: The candidate path data
        :rtype: List[PathData]
        """

        return self._candidate_path_data
    
    def SetCandidatePathData(self, candidate_path_data: List[PathData]) -> None:
        """
        Set the candidate path data

        :param List[PathData] candidate_path_data: The candidate path data to set
        """

        self._candidate_path_data = candidate_path_data
    
    def GetBlockingObstacle(self) -> Obstacle:
        """
        Get the blocking obstacle

        :returns: The blocking obstacle
        :rtype: Obstacle
        """

        return self._blocking_obstacle
    
    def SetBlockingObstacle(self, blocking_obstacle_id: str) -> None:
        """
        Set the blocking obstacle

        :param str blocking_obstacle_id: The obstacle to set
        """

        raise NotImplementedError
    
    def is_path_lane_borrow(self) -> bool:
        """
        Check if the path is lane borrow

        :returns: True if the path is lane borrow, otherwise False.
        :rtype: bool
        """

        return self._is_path_lane_borrow
    
    def set_is_path_lane_borrow(self, is_path_lane_borrow: bool) -> None:
        """
        Set the path is lane borrow

        :param bool is_path_lane_borrow: The value to set
        """

        self._is_path_lane_borrow = is_path_lane_borrow

    def set_is_on_reference_line(self) -> None:
        """
        Set the path is on reference line
        """

        self._is_on_reference_line = True
    
    def GetPriority(self) -> int:
        """
        Get the priority

        :returns: The priority
        :rtype: int
        """

        return self._reference_line.GetPriority()
    
    def SetPriority(self, priority: int) -> None:
        """
        Set the priority

        :param int priority: The priority to set
        """

        self._reference_line.SetPriority(priority)
    
    def set_trajectory_type(self, trajectory_type: ADCTrajectory.TrajectoryType) -> None:
        """
        Set the trajectory type

        :param ADCTrajectory.TrajectoryType trajectory_type: The trajectory type to set
        """

        self._trajectory_type = trajectory_type
    
    @property
    def trajectory_type(self) -> ADCTrajectory.TrajectoryType:
        """
        Get the trajectory type

        :returns: The trajectory type
        :rtype: ADCTrajectory.TrajectoryType
        """
            
        return self._trajectory_type

    @property
    def st_graph_data(self) -> StGraphData:
        """
        Get the st graph data
        
        :returns: The st graph data
        :rtype: StGraphData
        """

        return self._st_graph_data
    
    def FirstEncounteredOverlaps(self) -> List[Tuple[OverlapType, PathOverlap]]:
        """
        Get the first encountered overlaps

        :returns: The first encountered overlaps
        :rtype: List[Tuple[OverlapType, PathOverlap]]
        """

        return self._first_encounter_overlaps
    
    def GetPnCJunction(self, s: float) -> Tuple[int, PathOverlap]:
        """
        Get the pnc junction

        :param float s: The s value
        :returns: (int, PathOverlap pnc_junction_overlap)
        :rtype: Tuple[int, PathOverlap]
        """

        raise NotImplementedError
    
    def GetJunction(self, s: float) -> Tuple[int, PathOverlap]:
        """
        Get the junction

        :param float s: The s value
        :returns: (int, PathOverlap junction_overlap)
        :rtype: Tuple[int, PathOverlap]
        """

        raise NotImplementedError
    
    def GetAllStopDecisionSLPoint(self) -> List[SLPoint]:
        """
        Get all stop decision sl point

        :returns: The stop decision sl point
        :rtype: List[SLPoint]
        """

        raise NotImplementedError
    
    def SetTurnSignal(self, turn_signal: VehicleSignal.TurnSignal) -> None:
        """
        Set the turn signal

        :param VehicleSignal.TurnSignal turn_signal: The turn signal to set
        """

        raise NotImplementedError
    
    def SetEmergencyLight(self) -> None:
        """
        Set the emergency light
        """

        raise NotImplementedError
    
    def set_path_reusable(self, path_reusable: bool) -> None:
        """
        Set the path reusable

        :param bool path_reusable: The value to set
        """

        self._path_reusable = path_reusable
    
    @property
    def path_reusable(self) -> bool:
        """
        Get the path reusable

        :returns: The path reusable
        :rtype: bool
        """

        return self._path_reusable
    
    def GetOverlapOnReferenceLine(self, overlap_id: str, overlap_type: OverlapType) -> PathOverlap:
        """
        Get the overlap on reference line

        :param str overlap_id: The overlap id
        :param OverlapType overlap_type: The overlap type
        :returns: The overlap
        :rtype: PathOverlap
        """

        raise NotImplementedError
    
    def InitFirstOverlaps(self) -> None:
        """
        Init the first overlaps
        """

        map_path = self._reference_line.map_path
        # clear_zone
        tag, clear_area_overlap = self.GetFirstOverlap(map_path.clear_area_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.CLEAR_AREA, clear_area_overlap)

        # crosswalk
        tag, crosswalk_overlap = self.GetFirstOverlap(map_path.crosswalk_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.CROSSWALK, crosswalk_overlap)

        # pnc_junction
        tag, pnc_junction_overlap = self.GetFirstOverlap(map_path.pnc_junction_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.PNC_JUNCTION, pnc_junction_overlap)
        
        # signal
        tag, signal_overlap = self.GetFirstOverlap(map_path.signal_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.SIGNAL, signal_overlap)
        
        # stop_sign
        tag, stop_sign_overlap = self.GetFirstOverlap(map_path.stop_sign_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.STOP_SIGN, stop_sign_overlap)
        
        # yield_sign
        tag, yield_sign_overlap = self.GetFirstOverlap(map_path.yield_sign_overlaps)
        if tag:
            self._first_encounter_overlaps.append(self.OverlapType.YIELD_SIGN, yield_sign_overlap)
        
        # sort by start_s
        if self._first_encounter_overlaps:
            self._first_encounter_overlaps.sort(key=lambda x: x[1].start_s)

    def CheckChangeLane(self) -> bool:
        """
        Check if the vehicle is changing lane

        :returns: True if the vehicle is changing lane, otherwise False.
        :rtype: bool
        """

        raise NotImplementedError

    def SetTurnSignalBasedOnLaneTurnType(self) -> VehicleSignal:
        """
        Set the turn signal based on lane turn type

        :returns: The turn signal
        :rtype: VehicleSignal
        """

        raise NotImplementedError
    
    def ExportVehicleSignal(self) -> VehicleSignal:
        """
        Export the vehicle signal

        :returns: The vehicle signal
        :rtype: VehicleSignal
        """

        raise NotImplementedError
    
    def IsIrrelevantObstacle(obstacle: Obstacle) -> bool:
        """
        Check if the obstacle is irrelevant

        :param Obstacle obstacle: The obstacle to check
        :returns: True if the obstacle is irrelevant, otherwise False.
        :rtype: bool
        """

        raise NotImplementedError
    
    def MakeDecision(self) -> Tuple[DecisionResult, PlanningContext]:
        """
        Make decision

        :returns: (DecisionResult decision_result, PlanningContext planning_context)
        :rtype: Tuple[DecisionResult, PlanningContext]
        """
            
        raise NotImplementedError
    
    def MakeMainStopDecision(self) -> Tuple[int, DecisionResult]:
        """
        Make main stop decision

        :returns: (int, DecisionResult decision_result)
        :rtype: Tuple[int, DecisionResult]
        """

        raise NotImplementedError
    
    def MakeMainMissionCompleteDecision(self) -> Tuple[DecisionResult, PlanningContext]:
        """
        Make main mission complete decision

        :returns: (DecisionResult decision_result, PlanningContext planning_context)
        :rtype: Tuple[DecisionResult, PlanningContext]
        """

        raise NotImplementedError

    def MakeEStopDecision(self) -> DecisionResult:
        """
        Make E stop decision

        :returns: The decision result
        :rtype: DecisionResult
        """

        raise NotImplementedError
    
    def SetObjectDecisions(self) -> ObjectDecisions:
        """
        Set object decisions

        :returns: The object decisions
        :rtype: ObjectDecisions
        """

        raise NotImplementedError
    
    def AddObstacleHelper(self, obstacle: Obstacle) -> bool:
        """
        Add obstacle helper

        :param Obstacle obstacle: The obstacle to add
        :returns: True if successful, False otherwise
        :rtype: bool
        """

        return self.AddObstacle(obstacle) is not None
    
    def GetFirstOverlap(self, path_overlaps: List[PathOverlap]) -> Tuple[bool, PathOverlap]:
        """
        Get the first overlap

        :param List[PathOverlap] path_overlaps: The path overlaps
        :returns: (bool, The first overlap)
        :rtype: Tuple[bool, PathOverlap]
        """

        start_s: float = self._adc_sl_boundary.end_s
        kMaxOverlapRange: float = 500.0
        overlap_min_s: float = kMaxOverlapRange

        overlap_min_s_iter = path_overlaps[-1]
        for iter in path_overlaps:
            if iter.end_s < start_s:
                continue
            if overlap_min_s > iter.start_s:
                overlap_min_s_iter = iter
                overlap_min_s = iter.start_s

        # Ensure that the path_overlaps is not empty.
        if overlap_min_s_iter is not None:
            path_overlap = overlap_min_s_iter

        return (overlap_min_s < kMaxOverlapRange, path_overlap)

    def __copy__(self):
        """
        Disallow copy operation
        """

        raise NotImplementedError("Copy operation is not allowed")

    def __deepcopy__(self, memo):
        """
        Disallow deep copy operation
        """

        raise NotImplementedError("Deep copy operation is not allowed")
